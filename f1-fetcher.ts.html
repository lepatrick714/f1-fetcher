<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>F1 Race Telemetry Visualizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0d1117;
            color: #e6edf3;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        h1 {
            margin-bottom: 20px;
            color: #ff1e1e;
            font-size: 2em;
        }
        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 1000px;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background: #238636;
            color: white;
            border: none;
            border-radius: 6px;
            transition: background 0.3s;
        }
        button:hover:not(:disabled) {
            background: #2ea043;
        }
        button:disabled {
            background: #484f58;
            cursor: not-allowed;
        }
        input, select {
            padding: 10px;
            font-size: 16px;
            border-radius: 6px;
            border: 1px solid #30363d;
            background: #161b22;
            color: #e6edf3;
        }
        select {
            min-width: 200px;
        }
        .info {
            margin-bottom: 15px;
            font-size: 14px;
            color: #8b949e;
            text-align: center;
        }
        .progress-container {
            width: 100%;
            max-width: 800px;
            margin-bottom: 20px;
            display: none;
        }
        .progress-bar {
            width: 100%;
            height: 30px;
            background: #161b22;
            border-radius: 6px;
            overflow: hidden;
            border: 1px solid #30363d;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #238636, #2ea043);
            width: 0%;
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 12px;
        }
        .status-message {
            margin-top: 10px;
            font-size: 13px;
            color: #8b949e;
            text-align: center;
            min-height: 20px;
        }
        .status-error {
            color: #f85149;
        }
        .status-warning {
            color: #d29922;
        }
        .status-success {
            color: #3fb950;
        }
        #canvas-container {
            position: relative;
            border: 2px solid #30363d;
            border-radius: 8px;
            background: #0d1117;
        }
        canvas {
            display: block;
            border-radius: 6px;
        }
        .legend {
            margin-top: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 10px;
            max-width: 1000px;
            width: 100%;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
        }
        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 2px solid #fff;
            flex-shrink: 0;
        }
        .loading {
            color: #58a6ff;
            font-size: 18px;
        }
        .driver-select-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 15px;
            background: #161b22;
            border-radius: 6px;
            border: 1px solid #30363d;
            margin-bottom: 15px;
            max-width: 1000px;
            width: 100%;
        }
        .driver-checkboxes {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 8px;
            max-height: 200px;
            overflow-y: auto;
            padding: 10px;
            background: #0d1117;
            border-radius: 4px;
        }
        .driver-checkbox {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 13px;
        }
        .driver-checkbox input {
            width: auto;
        }
    </style>
</head>
<body>
    <h1>üèéÔ∏è F1 Race Telemetry Visualizer</h1>
    
    <div class="controls">
        <select id="yearSelect">
            <option value="2024">2024</option>
            <option value="2023" selected>2023</option>
        </select>
        <select id="raceSelect">
            <option value="">Select a race...</option>
        </select>
        <button id="loadRaceBtn">Load Race</button>
        <input type="file" id="fileInput" accept=".json" style="display: none;">
        <button id="loadFileBtn">Load from File</button>
    </div>

    <div class="driver-select-container" id="driverSelectContainer" style="display: none;">
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <strong>Select Drivers:</strong>
            <div>
                <button id="selectAllBtn" style="padding: 5px 10px; font-size: 14px;">Select All</button>
                <button id="deselectAllBtn" style="padding: 5px 10px; font-size: 14px;">Deselect All</button>
            </div>
        </div>
        <div class="driver-checkboxes" id="driverCheckboxes"></div>
        <button id="loadDriversBtn">Load Selected Drivers</button>
    </div>
    
    <div class="controls">
        <button id="playBtn" disabled>Play</button>
        <button id="pauseBtn" disabled>Pause</button>
        <button id="resetBtn" disabled>Reset</button>
        <input type="range" id="speedControl" min="1" max="50" value="5" disabled>
        <label for="speedControl">Speed: <span id="speedValue">5</span>x</label>
    </div>
    
    <div class="info" id="info">Select a year and race to begin</div>
    
    <div class="progress-container" id="progressContainer">
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill">0%</div>
        </div>
        <div class="status-message" id="statusMessage"></div>
    </div>
    
    <div id="canvas-container">
        <canvas id="raceCanvas" width="1200" height="700"></canvas>
    </div>
    
    <div class="legend" id="legend"></div>

    <script>
        const canvas = document.getElementById('raceCanvas');
        const ctx = canvas.getContext('2d');
        const info = document.getElementById('info');
        const legend = document.getElementById('legend');
        const progressContainer = document.getElementById('progressContainer');
        const progressFill = document.getElementById('progressFill');
        const statusMessage = document.getElementById('statusMessage');
        
        let allTelemetryData = {};
        let currentFrame = 0;
        let isPlaying = false;
        let animationId = null;
        let playbackSpeed = 5;
        let bounds = { minX: 0, maxX: 1000, minY: 0, maxY: 1000 };
        let driverColors = {};
        let selectedDrivers = [];
        let currentSessionKey = null;
        let maxFrames = 0;
        
        const colors = ['#ff1e1e', '#00d2be', '#0090ff', '#ff8700', '#2b4562', '#006f62', '#c92d4b', 
                        '#358c75', '#6692ff', '#f596c8', '#ff6b6b', '#4ecdc4', '#45b7d1', '#f9ca24',
                        '#6c5ce7', '#a29bfe', '#fd79a8', '#fdcb6e', '#e17055', '#74b9ff'];
        
        function updateProgress(current, total, message = '', type = '') {
            const percent = Math.round((current / total) * 100);
            progressFill.style.width = percent + '%';
            progressFill.textContent = percent + '%';
            
            if (message) {
                statusMessage.textContent = message;
                statusMessage.className = 'status-message';
                if (type === 'error') statusMessage.className += ' status-error';
                if (type === 'warning') statusMessage.className += ' status-warning';
                if (type === 'success') statusMessage.className += ' status-success';
            }
        }
        
        function showProgress() {
            progressContainer.style.display = 'block';
            progressFill.style.width = '0%';
            progressFill.textContent = '0%';
            statusMessage.textContent = '';
        }
        
        function hideProgress() {
            progressContainer.style.display = 'none';
        }
        
        async function fetchWithRetry(url, maxRetries = 10, baseDelay = 1000) {
            for (let attempt = 0; attempt < maxRetries; attempt++) {
                try {
                    const response = await fetch(url);
                    
                    if (response.status === 429) {
                        const delay = baseDelay * Math.pow(2, attempt);
                        updateProgress(0, 1, `‚ö†Ô∏è Hit rate limit (429). Retrying in ${(delay/1000).toFixed(1)}s... (Attempt ${attempt + 1}/${maxRetries})`, 'warning');
                        await new Promise(resolve => setTimeout(resolve, delay));
                        continue;
                    }
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    const data = await response.json();
                    
                    if (data.detail && data.detail.includes('too much data')) {
                        throw new Error('API returned too much data error');
                    }
                    
                    return data;
                    
                } catch (error) {
                    if (attempt === maxRetries - 1) {
                        throw error;
                    }
                    
                    const delay = baseDelay * Math.pow(2, attempt);
                    updateProgress(0, 1, `‚ùå Error: ${error.message}. Retrying in ${(delay/1000).toFixed(1)}s... (Attempt ${attempt + 1}/${maxRetries})`, 'error');
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }
        
        document.getElementById('yearSelect').addEventListener('change', loadRaces);
        document.getElementById('loadRaceBtn').addEventListener('click', loadRaceSession);
        document.getElementById('loadFileBtn').addEventListener('click', () => document.getElementById('fileInput').click());
        document.getElementById('fileInput').addEventListener('change', loadFromFile);
        document.getElementById('selectAllBtn').addEventListener('click', selectAllDrivers);
        document.getElementById('deselectAllBtn').addEventListener('click', deselectAllDrivers);
        document.getElementById('loadDriversBtn').addEventListener('click', loadSelectedDriversData);
        document.getElementById('playBtn').addEventListener('click', play);
        document.getElementById('pauseBtn').addEventListener('click', pause);
        document.getElementById('resetBtn').addEventListener('click', reset);
        document.getElementById('speedControl').addEventListener('input', (e) => {
            playbackSpeed = parseInt(e.target.value);
            document.getElementById('speedValue').textContent = playbackSpeed;
        });
        
        loadRaces();
        
        function saveToFile(data, sessionInfo) {
            const dataToSave = {
                sessionInfo: sessionInfo,
                telemetryData: data,
                savedAt: new Date().toISOString()
            };
            
            const blob = new Blob([JSON.stringify(dataToSave, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `f1_race_${sessionInfo.location.replace(/\s+/g, '_')}_${sessionInfo.session_key}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        function loadFromFile(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            info.textContent = 'Loading data from file...';
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const savedData = JSON.parse(e.target.result);
                    
                    if (!savedData.telemetryData || !savedData.sessionInfo) {
                        throw new Error('Invalid file format');
                    }
                    
                    allTelemetryData = savedData.telemetryData;
                    currentSessionKey = savedData.sessionInfo.session_key;
                    
                    // Reconstruct driver colors
                    Object.keys(allTelemetryData).forEach((driver, index) => {
                        if (!driverColors[driver]) {
                            driverColors[driver] = colors[index % colors.length];
                        }
                    });
                    
                    // Calculate max frames
                    maxFrames = 0;
                    Object.values(allTelemetryData).forEach(data => {
                        maxFrames = Math.max(maxFrames, data.length);
                    });
                    
                    calculateBounds();
                    updateLegend();
                    drawTrack();
                    
                    document.getElementById('playBtn').disabled = false;
                    document.getElementById('resetBtn').disabled = false;
                    document.getElementById('speedControl').disabled = false;
                    
                    const location = savedData.sessionInfo.location || 'Unknown';
                    info.textContent = `Loaded ${Object.keys(allTelemetryData).length} drivers from file (${location}). Ready to play!`;
                    
                } catch (error) {
                    console.error('Error loading file:', error);
                    info.textContent = 'Error loading file: ' + error.message;
                }
            };
            reader.readAsText(file);
        }
        
        async function loadRaces() {
            const year = document.getElementById('yearSelect').value;
            const raceSelect = document.getElementById('raceSelect');
            raceSelect.innerHTML = '<option value="">Loading races...</option>';
            
            try {
                const response = await fetch(`https://api.openf1.org/v1/sessions?session_type=Race&year=${year}`);
                const sessions = await response.json();
                
                raceSelect.innerHTML = '<option value="">Select a race...</option>';
                sessions.forEach(session => {
                    const option = document.createElement('option');
                    option.value = session.session_key;
                    option.textContent = `${session.location} - ${session.country_name} (${new Date(session.date_start).toLocaleDateString()})`;
                    raceSelect.appendChild(option);
                });
            } catch (error) {
                console.error('Error loading races:', error);
                raceSelect.innerHTML = '<option value="">Error loading races</option>';
            }
        }
        
        async function loadRaceSession() {
            const sessionKey = document.getElementById('raceSelect').value;
            if (!sessionKey) {
                alert('Please select a race');
                return;
            }
            
            currentSessionKey = sessionKey;
            info.textContent = 'Loading available drivers...';
            
            try {
                // Get session info for saving
                const sessionResponse = await fetch(`https://api.openf1.org/v1/sessions?session_key=${sessionKey}`);
                const sessionData = await sessionResponse.json();
                window.currentSessionInfo = sessionData[0];
                
                const response = await fetch(`https://api.openf1.org/v1/drivers?session_key=${sessionKey}`);
                const drivers = await response.json();
                
                const driverCheckboxes = document.getElementById('driverCheckboxes');
                driverCheckboxes.innerHTML = '';
                
                drivers.sort((a, b) => a.driver_number - b.driver_number).forEach((driver, index) => {
                    const label = document.createElement('label');
                    label.className = 'driver-checkbox';
                    label.innerHTML = `
                        <input type="checkbox" value="${driver.driver_number}" ${index < 5 ? 'checked' : ''}>
                        #${driver.driver_number}
                    `;
                    driverCheckboxes.appendChild(label);
                    
                    if (!driverColors[driver.driver_number]) {
                        driverColors[driver.driver_number] = colors[Object.keys(driverColors).length % colors.length];
                    }
                });
                
                document.getElementById('driverSelectContainer').style.display = 'block';
                info.textContent = `Found ${drivers.length} drivers. Select which ones to visualize (first 5 selected by default).`;
                
            } catch (error) {
                console.error('Error loading drivers:', error);
                info.textContent = 'Error loading drivers: ' + error.message;
            }
        }
        
        function selectAllDrivers() {
            document.querySelectorAll('.driver-checkbox input').forEach(cb => cb.checked = true);
        }
        
        function deselectAllDrivers() {
            document.querySelectorAll('.driver-checkbox input').forEach(cb => cb.checked = false);
        }
        
        async function loadSelectedDriversData() {
            const checkboxes = document.querySelectorAll('.driver-checkbox input:checked');
            selectedDrivers = Array.from(checkboxes).map(cb => cb.value);
            
            if (selectedDrivers.length === 0) {
                alert('Please select at least one driver');
                return;
            }
            
            if (selectedDrivers.length > 10) {
                if (!confirm(`Loading ${selectedDrivers.length} drivers may take a while and could hit API limits. Continue?`)) {
                    return;
                }
            }
            
            info.textContent = `Loading telemetry data for ${selectedDrivers.length} drivers...`;
            showProgress();
            allTelemetryData = {};
            maxFrames = 0;
            
            let loadedCount = 0;
            let failedCount = 0;
            const delayBetweenRequests = 1000; // 1 second between requests
            
            for (let i = 0; i < selectedDrivers.length; i++) {
                const driverNumber = selectedDrivers[i];
                
                try {
                    updateProgress(i, selectedDrivers.length, `Loading driver #${driverNumber}... (${loadedCount} loaded, ${failedCount} failed)`);
                    
                    // Add delay between requests (skip for first request)
                    if (i > 0) {
                        updateProgress(i, selectedDrivers.length, `‚è±Ô∏è Waiting ${delayBetweenRequests/1000}s before next request to avoid rate limits...`);
                        await new Promise(resolve => setTimeout(resolve, delayBetweenRequests));
                    }
                    
                    const data = await fetchWithRetry(
                        `https://api.openf1.org/v1/location?session_key=${currentSessionKey}&driver_number=${driverNumber}`,
                        10,
                        1000
                    );
                    
                    if (data && data.length > 0) {
                        // Sample data to reduce memory usage - take every 5th point
                        const sampledData = data.filter((_, idx) => idx % 5 === 0).sort((a, b) => new Date(a.date) - new Date(b.date));
                        allTelemetryData[driverNumber] = sampledData;
                        maxFrames = Math.max(maxFrames, sampledData.length);
                        loadedCount++;
                        updateProgress(i + 1, selectedDrivers.length, `‚úÖ Driver #${driverNumber} loaded! (${loadedCount}/${selectedDrivers.length})`, 'success');
                    } else {
                        failedCount++;
                        updateProgress(i + 1, selectedDrivers.length, `‚ö†Ô∏è No data for driver #${driverNumber} (${loadedCount} loaded, ${failedCount} failed)`, 'warning');
                    }
                    
                } catch (error) {
                    console.error(`Error loading driver ${driverNumber}:`, error);
                    failedCount++;
                    updateProgress(i + 1, selectedDrivers.length, `‚ùå Failed to load driver #${driverNumber}: ${error.message}`, 'error');
                }
            }
            
            if (Object.keys(allTelemetryData).length === 0) {
                info.textContent = 'No data found for selected drivers';
                hideProgress();
                return;
            }
            
            calculateBounds();
            updateLegend();
            drawTrack();
            
            document.getElementById('playBtn').disabled = false;
            document.getElementById('resetBtn').disabled = false;
            document.getElementById('speedControl').disabled = false;
            
            updateProgress(selectedDrivers.length, selectedDrivers.length, `üéâ Successfully loaded ${loadedCount} drivers!`, 'success');
            info.textContent = `Loaded data for ${Object.keys(allTelemetryData).length} drivers. Ready to play!`;
            
            // Save data to file
            if (window.currentSessionInfo) {
                saveToFile(allTelemetryData, window.currentSessionInfo);
                info.textContent = `Loaded ${Object.keys(allTelemetryData).length} drivers. Data saved to file!`;
            }
            
            // Hide progress after 3 seconds
            setTimeout(hideProgress, 3000);
        }
        
        function calculateBounds() {
            let allX = [];
            let allY = [];
            
            Object.values(allTelemetryData).forEach(data => {
                allX.push(...data.map(d => d.x));
                allY.push(...data.map(d => d.y));
            });
            
            bounds = {
                minX: Math.min(...allX),
                maxX: Math.max(...allX),
                minY: Math.min(...allY),
                maxY: Math.max(...allY)
            };
        }
        
        function updateLegend() {
            legend.innerHTML = '';
            Object.keys(allTelemetryData).sort((a, b) => parseInt(a) - parseInt(b)).forEach(driver => {
                const item = document.createElement('div');
                item.className = 'legend-item';
                item.innerHTML = `
                    <div class="legend-color" style="background-color: ${driverColors[driver]}"></div>
                    <span>Driver #${driver}</span>
                `;
                legend.appendChild(item);
            });
        }
        
        function scaleX(x) {
            const padding = 50;
            const width = canvas.width - 2 * padding;
            return padding + ((x - bounds.minX) / (bounds.maxX - bounds.minX)) * width;
        }
        
        function scaleY(y) {
            const padding = 50;
            const height = canvas.height - 2 * padding;
            return padding + ((y - bounds.minY) / (bounds.maxY - bounds.minY)) * height;
        }
        
        function drawTrack() {
            ctx.fillStyle = '#0d1117';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw track outline from first driver's data
            const firstDriver = Object.values(allTelemetryData)[0];
            if (!firstDriver) return;
            
            ctx.strokeStyle = '#30363d';
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            for (let i = 0; i < firstDriver.length; i++) {
                const x = scaleX(firstDriver[i].x);
                const y = scaleY(firstDriver[i].y);
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
        }
        
        function drawCar(data, color, driverNumber) {
            const x = scaleX(data.x);
            const y = scaleY(data.y);
            
            // Draw car as circle with glow
            ctx.shadowBlur = 10;
            ctx.shadowColor = color;
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x, y, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // Draw white center
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(x, y, 3, 0, Math.PI * 2);
            ctx.fill();
        }
        
        function animate() {
            if (!isPlaying) return;
            
            drawTrack();
            
            // Draw all drivers
            Object.entries(allTelemetryData).forEach(([driverNumber, data]) => {
                if (currentFrame < data.length) {
                    // Draw trail
                    const trailLength = Math.min(100, currentFrame);
                    ctx.strokeStyle = driverColors[driverNumber] + '40';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    
                    for (let i = Math.max(0, currentFrame - trailLength); i <= currentFrame; i++) {
                        const x = scaleX(data[i].x);
                        const y = scaleY(data[i].y);
                        
                        if (i === Math.max(0, currentFrame - trailLength)) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.stroke();
                    
                    // Draw car
                    drawCar(data[currentFrame], driverColors[driverNumber], driverNumber);
                }
            });
            
            const progressPercent = ((currentFrame / maxFrames) * 100).toFixed(1);
            info.textContent = `Frame ${currentFrame}/${maxFrames} (${progressPercent}%)`;
            
            currentFrame += playbackSpeed;
            
            if (currentFrame >= maxFrames) {
                pause();
                info.textContent = 'Race complete! Click Reset to replay.';
                return;
            }
            
            animationId = requestAnimationFrame(animate);
        }
        
        function play() {
            if (Object.keys(allTelemetryData).length === 0) return;
            isPlaying = true;
            document.getElementById('playBtn').disabled = true;
            document.getElementById('pauseBtn').disabled = false;
            animate();
        }
        
        function pause() {
            isPlaying = false;
            document.getElementById('playBtn').disabled = false;
            document.getElementById('pauseBtn').disabled = true;
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
        }
        
        function reset() {
            pause();
            currentFrame = 0;
            drawTrack();
            info.textContent = `Ready to replay. Data loaded for ${Object.keys(allTelemetryData).length} drivers.`;
        }
    </script>
</body>
</html>